<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    
    <title>iOS 7教程 - StoryBoards Part2 | Andy矢倉</title>
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <meta name="description" content="曾梦想仗剑走天涯">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="iOS 7教程 - StoryBoards Part2 | Andy矢倉">
    <meta name="twitter:description" content="曾梦想仗剑走天涯">

    <meta property="og:type" content="article">
    <meta property="og:title" content="iOS 7教程 - StoryBoards Part2 | Andy矢倉">
    <meta property="og:description" content="曾梦想仗剑走天涯">

    
    <meta name="author" content="Andy矢倉">
    
    <link rel="stylesheet" href="/css/vno.css">
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css">

    
    <link rel="icon" href="/images/favicon.ico">
    

    <meta name="generator" content="hexo"/>
    
    <link rel="alternate" type="application/rss+xml" title="Andy矢倉" href="/atom.xml">
    

    <link rel="canonical" href="http://shicang1990.github.io/2014/03/04/2014-03-04-Storyboard-Party2/"/>

    
      
</head>

<body class="home-template no-js">
    <script src="http://cdn.bootcss.com/jquery/2.1.4/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>

    
<header class="panel-cover panel-cover--collapsed" style="background-image: url(/images/background-cover.jpg)">
  <div class="panel-main">
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/" title="前往 Andy矢倉 的主页"><img src="/images/favicon.ico" width="80" alt="Andy矢倉 logo" class="panel-cover__logo logo" /></a>
        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage for Andy矢倉">Andy矢倉</a></h1>
        
        <span class="panel-cover__subtitle panel-subtitle">老板 来杯董小姐 去冰 少糖 多放点小姐</span>
        
        <hr class="panel-cover__divider" />
        <p class="panel-cover__description">曾梦想仗剑走天涯</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />

        <div class="navigation-wrapper">
          <div>
          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">
              <li class="navigation__item"><a href="/#blog" title="访问博客" class="blog-button">博客</a></li>
            
              <li class="navigation__item"><a href="/">主页</a></li>
            
              <li class="navigation__item"><a href="/archives">所有文章</a></li>
            
            </ul>
          </nav>
          </div>
          <div>
          <nav class="cover-navigation navigation--social">
  <ul class="navigation">

  <!-- Weibo-->
  
  <li class="navigation__item">
    <a href="http://weibo.com/ganmaojijie" title="我的微博" target="_blank">
      <i class='social fa fa-weibo'></i>
      <span class="label">Weibo</span>
    </a>
  </li> 


  <!-- Github -->
  
  <li class="navigation__item">
    <a href="https://github.com/shicang1990" title="查看我的GitHub主页" target="_blank">
      <i class='social fa fa-github'></i>
      <span class="label">Github</span>
    </a>
  </li>


<!-- Stack Overflow -->
        

  <!-- Google Plus -->
  

<!-- Facebook -->

  <li class="navigation__item">
    <a href="https://www.facebook.com/wiwby" title="上Facebook找我" target="_blank">
      <i class='social fa fa-facebook'></i>
      <span class="label">Facebook</span>
    </a>
  </li>

  
<!-- Twitter -->

  <li class="navigation__item">
    <a href="https://twitter.com/Andy_shicang" title="上Twitter找我" target="_blank">
      <i class='social fa fa-twitter'></i>
      <span class="label">Twitter</span>
    </a>
  </li>

  

  <li class="navigation__item">
    <a href="/atom.xml" title="RSS" target="_blank">
      <i class='social fa fa-rss'></i>
      <span class="label">RSS</span>
    </a>
  </li>


  <li class="navigation__item">
    <a href="mailto:shicang1990@gmail.com" title="邮件联系我" target="_blank">
      <i class='social fa fa-envelope'></i>
      <span class="label">Email</span>
    </a>
  </li>


  </ul>
</nav>

          </div>
        </div>

      </div>

    </div>

    <div class="panel-cover--overlay cover-purple"></div>
  </div>
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single">

  <header class="post-header">
    <div class="post-meta">
      <time datetime="2014-03-04T08:30:08.000Z" class="post-list__meta--date date">3月 4 2014</time> &#8226; <span class="post-meta__tags tags">于&nbsp;
  <a class="tag-link" href="/tags/StoryBoard/">StoryBoard</a>, <a class="tag-link" href="/tags/iOS7/">iOS7</a>
 </span>
      <span class="page-pv">
      &nbsp;阅读&nbsp;<span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span>
      </span> 
   
    </div>
    <h1 class="post-title">iOS 7教程 - StoryBoards Part2</h1>
  </header>

  <section class="post">
    <p>原文地址：<a href="http://www.raywenderlich.com/50310/storyboards-tutorial-in-iOS-7-part-2" target="_blank" rel="external">http://www.raywenderlich.com/50310/storyboards-tutorial-in-iOS-7-part-2</a><br>iOS 7教程 - Storyboards Part1 译文地址：<a href="http://www.tairan.com/archives/5365" target="_blank" rel="external">iOS 7教程 - Storyboards Part1</a></p>
<blockquote>
<p>iOS开发也好些日子了，一直都是纯code，偶尔用用xib，最近闲来无事想体验下storyboard，于是网上找到了各种关于storyboard的入门教程，可惜很多都比较老了都是iOS5，和iOS6系列的教程，我想这xcode都更新小半年了，iOS7.1都快出了，再整老版本不太合适吧，于是找到了泰然网翻译的一篇iOS7 storyboard教程，可惜只翻译了第一篇，第二篇估计还没来得及吧！捉摸着都看了开头了，怎么着也得看完是吧，就寻着原文找到了第二篇，坑爹的英文，虽然不是很感冒鸟文，加上Google也多少能看明白，一下算是自己理解的然后加上些口水话，有兴趣的童鞋凑合着看吧，第一次翻译，哈哈哈，开始吧，Ready,go…</p>
</blockquote>
<p><em>温馨提示：教程成员Matthijs Hollemans(iOS Apprentice系列的作者)已经发表了这个教程的iOS5版本至iOS7版本。这是本书第三版的预览,这个版本将会更新到iOS 7。好好享受吧!</em></p>
<a id="more"></a>
<blockquote>
<p>如果你想了解storyboard on iOS7，那你来对地方了！<br>在storyboard on iOS7系列教程的第一部分，已经介绍了使用Interface Builder来创建和连接各种视图控制器的基本知识，以及如何直接从storyboard编辑器进行自定义表视图单元格。<br>在本教程系列的第二个和最后部分，我们将讨论segues，静态表视图单元格，添加播放器场景，和游戏场景！<br>如果你跟着上一次的教程走完了整个步骤，那就把上一次的工程打开！<br>好吧，让我们深入到storyboard其他酷毙的功能！</p>
</blockquote>
<p>##介绍segues<br>现在是时候添加更多的视图控制器到<strong>storyboard</strong>了，我们来创建一个新的场景。<br>打开<strong>Main.storyboard</strong>并拖动一个<strong>Bar Button Item</strong>到<strong>Players</strong>场景里的<strong>navigation bar</strong>中。在属性检查器<strong>(Attributes inspector)</strong>改变它的标示符<strong>(Identifier)</strong>变为加号<strong>(Add)</strong>。</p>
<p><img src="http://i3.tietuku.cn/23898e59fbc1789e.png" alt=""></p>
<p>当用户点击这个 <strong>+</strong> 按钮的时候应用程序会弹出一个新的表演者详细信息的模态视图。 </p>
<p>将一个新的导航控制器<strong>(Navigation Controller)</strong>拖拽到表演者视图的右边。记住，你可以双击<strong>storyboard</strong>缩小让你有更大的工作空间。新的导航控制器都附带一个表视图控制器，应该已经得心应手了吧！<br>窍门：点击刚刚在表演者视图上添加的那个 <strong>+</strong> 按钮，按住<strong>ctrl</strong>并且拽向导航控制器</p>
<p><img src="http://i3.tietuku.cn/a5a0397722fdbe87.png" alt=""></p>
<p>松开鼠标将会弹出如下选项：</p>
<p><img src="http://i3.tietuku.cn/8bddbab0120e9a8d.png" alt=""></p>
<p>选择<strong>modal</strong>，这是视图跳转的一种新的路径(这句不知道怎么翻译好，就理解为两种视图之间的跳转好了):</p>
<p><img src="http://i3.tietuku.cn/0eabae66b455ebb9.png" alt=""></p>
<p>这样的链接关系就称之为：<strong>segue</strong>。这种故事板的链接关系是从一个视图控制器跳转到另外一个视图控制器。</p>
<p>使用<strong>segue</strong>很酷的事情就是，你再也不用编写任何代码来实现控制器跳转，也不必为你的按钮挂接到<strong>IBActions</strong>。只需要想刚才那样一个拖动就可以搞定了。(注：如果您的控件已经有了一个<strong>IBAction</strong>连接，那么<strong>segue</strong>将覆盖它。)</p>
<p>让我们来运行一下，点击刚才添加的那个 <strong>+</strong> 按钮，一个新的表视图将呈现在你的眼前</p>
<p><img src="http://i3.tietuku.cn/211f247ca963f5a5.png" alt=""></p>
<p>这个所谓的模态关系。新的场景将完全掩盖了前一个场景。用户不能与前一个场景交互，直到他们关闭了模态视图。以后你还会看到，在导航控制器的堆栈上还可以以推动的方式跳转。</p>
<p>新的场景挺好用吧，但有个问题是你不能关闭他返回到刚才的场景。这是因为<strong>segue</strong>是单向的，一个场景到另一个场景。回去的时候，你必须使用<strong>delegate</strong>模式。鉴于这种情况，你需要先新建视图控制器。</p>
<p>添加一个新的文件添加到项目，并命名为<strong>PlayerDetailsViewController</strong>，它是<strong>UITableViewController</strong>的子类。切换回<strong>Main.storyboard</strong>并选择新的表视图控制器的场景<strong>(Root View Controller)</strong>。在<strong>Identity inspector</strong>中设置其<strong>class</strong>为<strong>PlayerDetailsViewController</strong>。我就是经常忘了这么做，所以这里需要提醒一下。</p>
<p>改变新建表视图的标题为：<strong>Add Player</strong>(通过双击导航栏)。同时添加两个<strong>Bar Button Item</strong>到导航栏左右两边。在属性检查器<strong>(Attributes inspector)</strong>中，左边的按钮改名为：<strong>Cancel</strong>，右边的按钮改名为：<strong>Done</strong>(你也可以通过改变按钮的stye来得到相同的效果)。</p>
<p><img src="http://i3.tietuku.cn/54fbf56e19ddba98.png" alt=""></p>
<p>把<code>PlayerDetailsViewController.h</code>改成下面这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">@class PlayerDetailsViewController;</div><div class="line"> </div><div class="line">@protocol PlayerDetailsViewControllerDelegate </div><div class="line">- (void)playerDetailsViewControllerDidCancel:(PlayerDetailsViewController *)controller;</div><div class="line">- (void)playerDetailsViewControllerDidSave:(PlayerDetailsViewController *)controller;</div><div class="line">@end</div><div class="line"> </div><div class="line">@interface PlayerDetailsViewController : UITableViewController</div><div class="line"> </div><div class="line">@property (nonatomic, weak) id  delegate;</div><div class="line"> </div><div class="line">- (IBAction)cancel:(id)sender;</div><div class="line">- (IBAction)done:(id)sender;</div><div class="line"> </div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这里我们定义了一个委托协议，好让新的场景可以返回上一个场景，并且添加了<strong>cancel</strong>和<strong>done</strong>按钮的两个点击事件。</p>
<p>切换到故事版，点击新建的表视图导航栏上那个<strong>done</strong>按钮，按住<strong>ctrl</strong>进行拖拽，拖拽箭头如下图所示：</p>
<p><img src="http://i3.tietuku.cn/c7939432b8630267.png" alt=""></p>
<p>选择<strong>Sent Actions</strong>栏里的<code>done</code>事件，同样，<strong>cancel</strong>按钮也如此步骤，选择<code>cancel</code>事件。</p>
<p>到<code>PlayerDetailsViewController.m</code>源文件里添加下面两个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (IBAction)cancel:(id)sender</div><div class="line">&#123;</div><div class="line">    [self.delegate playerDetailsViewControllerDidCancel:self];</div><div class="line">&#125;</div><div class="line">- (IBAction)done:(id)sender</div><div class="line">&#123;</div><div class="line">    [self.delegate playerDetailsViewControllerDidSave:self];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是对应两个按钮的点击事件方法。我们可以用它来调用代理，通过代理方法来关闭当前的场景或者视图。它是由委托关闭屏幕。（这里默认的是必须实现方法，你要不喜欢可以改成选用，在协议方法前面加上@optional字段。或者你也可以通过当前控制器自行关闭，并且在关闭前后通知代理）。</p>
<blockquote>
<p>注释：在这里代理方法只有一个对象作为参数，在这种情况下，<strong>PlayerDetailsViewController</strong>。好处代理总是知道是哪个对象发送的消息。</p>
</blockquote>
<p>之前，我们已经给了<strong>PlayerDetailsViewController</strong>委托协议，但是你需要实现这个协议和协议方法。<strong>PlayersViewController</strong>将呈现的添加播放器屏幕的视图控制器。以下内容添加到<code>PlayersViewController.h</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#import &quot;PlayerDetailsViewController.h&quot;</div><div class="line"> </div><div class="line">@interface PlayersViewController : UITableViewController</div></pre></td></tr></table></figure>
<p>实现代理方法<code>PlayersViewController.m</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#pragma mark - PlayerDetailsViewControllerDelegate</div><div class="line"> </div><div class="line">- (void)playerDetailsViewControllerDidCancel:(PlayerDetailsViewController *)controller</div><div class="line">&#123;</div><div class="line">    [self dismissViewControllerAnimated:YES completion:nil];</div><div class="line">&#125;</div><div class="line"> </div><div class="line">- (void)playerDetailsViewControllerDidSave:(PlayerDetailsViewController *)controller</div><div class="line">&#123;</div><div class="line">    [self dismissViewControllerAnimated:YES completion:nil];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>目前，这些委托方法只是关闭当前视图控制器。以后会让他们做更多有趣的事情。 </strong><br>现在还差一件事情没做了，设置<strong>PlayersViewController</strong>为<strong>PlayerDetailsViewController</strong>的代理。你可能以为在<strong>Interface Builder</strong>我们可以连线来解决。但很不幸的是，这是不可能的。传输数据到新的视图控制器，你仍然需要编写一些代码。（最后不怎么会翻译，就理解为<strong>storyboard</strong>的方式设置代理没办法连线解决，只能通过代码设置代理）<br>将以下方法添加到<code>PlayersViewController.m</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender</div><div class="line">&#123;</div><div class="line">    if ([segue.identifier isEqualToString:@&quot;AddPlayer&quot;]) &#123;</div><div class="line"> </div><div class="line">        UINavigationController *navigationController = segue.destinationViewController;</div><div class="line">        PlayerDetailsViewController *playerDetailsViewController = [navigationController viewControllers][0];</div><div class="line">        playerDetailsViewController.delegate = self;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>prepareForSegue</strong>这个方法在新视图从<strong>storyboard</strong>上加载的时候就会被处罚，但是它是不可见，需要手动实现，所以我们可以用它来设置代理。</p>
<blockquote>
<p>注意：一般情况下不会调用<code>prepareForSegue:</code>方法。这是一个从UIKit的一条消息，让你知道，<strong>segue</strong>被触发了。</p>
</blockquote>
<p>这个<strong>segue</strong>的目的地是导航控制器，因为那是你连接到栏按钮项目。要获得<strong>PlayerDetailsViewController</strong>实例，你必须通过<strong>viewControllers</strong>的导航控制器的堆栈来得到它。<br>运行应用程序，按下 <strong>+</strong> 按钮，并尝试关闭添加播放器画面。它仍然无法正常工作！</p>
<p><img src="http://i3.tietuku.cn/3c299f58255873ea.png" alt=""></p>
<p>那是因为你没有给<strong>segue</strong>标识符。从<strong>prepareForSegue</strong>代码检查该标识符<strong>(“AddPlayer”)</strong>。因此建议经常做这样的检查，因为你可能有多个<strong>segue</strong>到一个视图控制器，你就需要他们各自的区别开来。<br>要解决此问题，请打开<strong>Main.storyboard</strong>并点击玩家屏幕和导航控制器之间的<strong>segue</strong>。请注意，栏按钮项目现在亮起，这样你就可以很容易地看到哪些控制触发此<strong>SEGUE</strong>。<br>在<strong>属性检查器(Attributes inspector)</strong>中，标识符<strong>(Identifier)</strong>设置为<strong>AddPlayer</strong>：</p>
<p><img src="http://i3.tietuku.cn/f99aef067c9b0d36.png" alt=""></p>
<p>再次运行程序，这下是不是就可以正常关闭弹出的模态视图啦！</p>
<blockquote>
<p>注意：这本来完全可以调用dismissViewControllerAnimated：来完成弹出模态画面的。也没有规定说，委托必须做到这一点。我个人更喜欢让委托处理这一点，但如果你想模态视图关闭本身，那么请随意。</p>
</blockquote>
<p>顺便，在属性检查器里可以设置segue的跳转过程（视图控制器的跳转过程），你可以设计几种过场动画：</p>
<p><img src="http://i3.tietuku.cn/58393311095bb3de.png" alt=""></p>
<p>选择一个你喜欢的过场动画，但是记住千万别改变风格<strong>(style)</strong>设置，因为这里的链接是模态关系 - 改变会导致应用程序的崩溃，切记！<br>我们将会在本教程中使用几次委托协议，下面是个核对列表供你检查两个场景之间的链接关系：</p>
<ul>
<li>通过一个按钮或者其他控件创建一个sugue来链接源场景到目标场景(如果你是新建模态视图，这时目标场景将是一个导航控制器)。</li>
<li>给segue的唯一标识符(源场景必须有唯一的标示符，不同的场景可以使用相同的标识符)。</li>
<li>为目标场景创建一个委托协议。 </li>
<li>调用取消和完成按钮的委托方法，你的目的地的场景需要与源场景进行通信(两个视图控制器之间的通讯)。</li>
<li>源场景实现委托协议。当取消或完成按钮被按下，它应该关闭该目标视图控制器。</li>
<li>在源视图控制器实现<code>prepareForSegue:</code>方法，并且把目标视图控制器的代理设置为源视图控制(eg:playerDetailsViewController.delegate = self)。</li>
</ul>
<p>委托是必须的，因为至少在<strong>iOS5</strong>没有东西可以作为一个<strong>“反向segue”</strong>。当<strong>segue</strong>被触发，当<strong>segue</strong>被触发的时候总是会为目标视图控制器创建一个实例。你当然可以做一个反向的<strong>segue</strong>从目的到源，但可能不会做你所期望的(这段搞不懂，谷歌翻译的)。<br>如果你是为表演者场景创建一个<strong>segue</strong>回来的取消按钮，例如，那么这将不会关闭添加表演者场景，并返回到表演者，但它创造的表演者场景的新实例。你这样一遍一遍的创建新的视图控制器会导致内存溢出(也是没看懂，没办法翻译，针对上面没看懂的这两段，我没管，看下面这个提示就够了！)。<br>请记住：<strong>segue</strong>只有一条路可走，它们只是用来进入一个新的场景。要返回您之前的场景(或从导航控制器堆栈中弹出它)，通常是用<strong>delegate</strong>。<strong>segue</strong>仅由源控制器使用。目标视图控制器甚至不知道它是被<strong>segue</strong>调用。</p>
<p>##静态单元格</p>
<p>在本章结束的时候你的添加表演者场景会像下面这样：</p>
<p><img src="http://i3.tietuku.cn/7ce08f3f116dc6e5.png" alt=""></p>
<p>这是一个分组表视图，当然，你不必为此表格创建一个数据源。您可以在<strong>Interface Builder</strong>中直接设计它 - 没必要单独为它写一个<code>cellForRowAtIndexPath</code>方法，这种称为静态单元格。<br>在添加表演者控制器里选择表视图，在<strong>属性检查器(Attributes inspector)</strong>里改变<strong>content</strong>为<strong>static cells</strong>。把<strong>style</strong>改变为<strong>Grouped</strong>，并且设置两个组<strong>(两个section)</strong>。</p>
<p><img src="http://i3.tietuku.cn/573a7955e21691a5.png" alt=""></p>
<p>当您更改<strong>section</strong>的属性值时，编辑器将复制现有的部分(你也可以自己手动复制)。<br>完成后的场景里每个<strong>section</strong>里只有一个<strong>cell</strong>，多余的就把它们删了吧(别说你不会删)。<br>选择<strong>Table View Section</strong>，这个可能不是很好点中，那你就在编辑器或者导航条上选吧，这样就妥妥的了，像这样：</p>
<p><img src="http://i3.tietuku.cn/c0555763899d4a8a.png" alt=""></p>
<p>或者这样</p>
<p><img src="http://i3.tietuku.cn/fb86236d2fb7f025.png" alt=""></p>
<p>OK，我们选中之后就在属性检查器中把<strong>Header</strong>改为<strong>Player Name</strong>。<br>然后我们拖拽一个<strong>TextField</strong>控件到<strong>cell</strong>里面去，调整边距到<strong>cell</strong>的<strong>contentview</strong>一样大，然后设置<strong>font</strong>为<strong>system 17</strong>，<strong>border style</strong>改为第一个样式(目前是圆角样式)，把<strong>adjust to fit</strong>的勾勾取消掉。</p>
<p>我们将使用<strong>Xcode</strong>的助理编辑功能，在<strong>PlayerDetailsViewController</strong>里创建之前拖拽到<strong>cell</strong>里的那个<strong>text field</strong>的接口。打开<strong>助理编辑用工具栏(Assistant Editor)</strong>上的按钮(一个看起来像燕尾服/外星人的脸)。它应该会把<code>PlayerDetailsViewController.h</code>自动打开(如果没有，请使用jump bar在右手分割窗口来选择头.h文件)。 </p>
<p>选择<strong>text field</strong>并按住<strong>Ctrl</strong>键拽入.h文件：</p>
<p><img src="http://i3.tietuku.cn/be6a5970062c5a9e.png" alt=""></p>
<p>松开鼠标按钮就弹出了这种小窗口</p>
<p><img src="http://i3.tietuku.cn/4f8f3593e1ca1a06.png" alt=""></p>
<p>把新的接口命名为nameTextField，链接之后xcode会自动在PlayerDetailsViewController.h加上属性:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (weak, nonatomic) IBOutlet UITextField *nameTextField;</div></pre></td></tr></table></figure>
<p>现在，点击第二个<strong>section</strong>里的静态单元格，把<strong>Style</strong>改为<strong>Right Detail</strong>，这是一个标准的单元格样式，点击<strong>cell</strong>里左边的<strong>label</strong>，把<strong>label</strong>内容改为<strong>Game</strong>并且把<strong>accessory</strong>风格改为<strong>Disclosure Indicator</strong>。（不知道是版本问题还是什么，我在xcode5.0.2上发现改了label的内容什么都没有，后来发现字体大小为0，次奥，以前xib没这情况啊，继续。。。）<br>把<strong>cell</strong>右边的<strong>label</strong>也改了，内容改为<strong>Detail</strong>，然后重复刚才拖拽<strong>text field</strong>的步骤一样，为这个<strong>label</strong>新建一个接口并命名为<strong>detailLabel</strong>，就像这样</p>
<p><img src="http://i3.tietuku.cn/865fa1820fc068fb.png" alt=""></p>
<p>添加播放器页面的最终看起来像这样</p>
<p><img src="http://i3.tietuku.cn/4697f22058e91ec6.png" alt=""></p>
<blockquote>
<p>提示：现在这个设计的屏幕都为iPhone5的，屏幕高568个像素点，相对于以前的iPhone机型的4英寸屏幕的高度为480个像素点。您可以使用最左边的按钮，从小事浮动面板，坐落在画布的底部这两种形式的因素之间进行切换。</p>
</blockquote>
<p><img src="http://i3.tietuku.cn/2939d1d29eaa4d6b.png" alt=""></p>
<p>很明显，你的应用程序应该正常工作与两个屏幕大小。您可以使用自动调整大小口罩或从的iOS 6新的自动布局技术实现这一点。对于评级的应用程序，你不必做任何幻想。它仅使用表格视图控制器，它们会自动调整大小以适合在iPhone5的额外的屏幕空间。<br>返回到添加表演者页面。当您使用静态的单元格，你的表视图控制器不需要一个数据源。由于您使用的<strong>Xcode</strong>的模板来创建<strong>PlayerDetailsViewController</strong>类，它仍然有数据源的一些占位符代码，这将防止静态单元格无法正常工作。<br>打开<code>PlayerDetailsViewController.m</code>，把下面这段一下的代码都删掉(除了你自己添加任何代码):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#pragma mark - Table view data source</div></pre></td></tr></table></figure>
<p>这样删除之后你运行来试试看是不是可以工作了，对于静态单元格你基本可以不用写任何代码，除了控制代码之外。<br>这里还有个问题就是<strong>text field</strong>没有整个覆盖在<strong>cell</strong>上面，你点击<strong>cell</strong>边缘的时候键盘是不会弹出的。<br>为了避免这种情况，你应该让第一行单元格里调出键盘。这是很容易做到，只需添加一个这个方法<code>didSelectRowAtIndexPath:</code>实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath</div><div class="line"></div><div class="line">&#123;</div><div class="line">    if (indexPath.section == 0) &#123;</div><div class="line">        [self.nameTextField becomeFirstResponder];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这只是说，如果用户点击第一个单元格，应用程序应该激活<strong>text filed</strong>。我们用代码调整当点击第一个<strong>section</strong>里的<strong>cell</strong>时候，应该激活<strong>text field</strong>，这是为了更好的用户体验。<br>还有，我们应该选择<strong>cell</strong>，把<strong>selection</strong>的风格从<strong>blue</strong>改变为<strong>none</strong>，这样就没有了之前那样点击<strong>text field</strong>没有覆盖到的<strong>cell</strong>部分的时候出现高亮暗影而影响用户体验了。<br>好吧，这是添加表演者场景的设计。现在，让我们真正使其发挥作用。</p>
<p>##让添加表演者视图工作吧</p>
<p>现在你会忽略了游戏的行，只是让用户输入玩家的名字。<br>当用户按下<strong>Cancel</strong>按钮，屏幕应该关闭，任何数据都将丢失。这部分已经没问题了。委托(在玩家屏幕)接收”并取消”的消息，并简单地反馈给视图控制器。<br>当用户按下<strong>Done</strong>(完成)，但是，你应该创建一个新的表演者对象，并填写其属性。那么你应该告诉代理已经添加了一个新的，使它好更新自己的视图。<br>现在<code>PlayerDetailsViewController.m</code>导入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#import &quot;Player.h&quot;</div></pre></td></tr></table></figure>
<p>接着改变<code>done:</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (IBAction)done:(id)sender</div><div class="line">&#123;</div><div class="line">    Player *player = [[Player alloc] init];</div><div class="line">    player.name = self.nameTextField.text;</div><div class="line">    player.game = @&quot;Chess&quot;;</div><div class="line">    player.rating = 1;</div><div class="line">    [self.delegate playerDetailsViewController:self didAddPlayer:player];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>done:</code>方法现在创建一个新的<strong>player</strong>实例，并把它发送给该委托。委托协议目前并无此方法，所以<code>PlayerDetailsViewController.h</code>文件内容要稍稍改变一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@class Player;</div><div class="line"> </div><div class="line">@protocol PlayerDetailsViewControllerDelegate </div><div class="line">- (void)playerDetailsViewControllerDidCancel:(PlayerDetailsViewController *)controller;</div><div class="line">- (void)playerDetailsViewController:(PlayerDetailsViewController *)controller didAddPlayer:(Player *)player;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>所以在新的代理方法里面要作一些新的改变：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (void)playerDetailsViewController:(PlayerDetailsViewController *)controller didAddPlayer:(Player *)player</div><div class="line">&#123;</div><div class="line">    [self.players addObject:player];</div><div class="line">    NSIndexPath *indexPath = [NSIndexPath indexPathForRow:([self.players count] - 1) inSection:0];</div><div class="line">    [self.tableView insertRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationAutomatic];</div><div class="line">    [self dismissViewControllerAnimated:YES completion:nil];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的意思就是把新建的<strong>player</strong>对象加到<strong>players</strong>数组里去，然后<strong>通知表视图(table view)</strong>新增加了一行，因为<strong>表视图(table view)</strong>和<strong>数据源(data source)</strong>数据必须同步。<br>你可以只执行<code>[self.tableView reloadData]</code>这个方法，但是为了给表视图插入新的行有动画效果，<code>UITableViewRowAnimationAutomatic</code>这个枚举类型的参数是自动选择动画效果，非常方便。<br>现在试试吧，你应该能在列表里看到新加入的行了！</p>
<p><img src="http://i3.tietuku.cn/541454d0057978d4.png" alt=""></p>
<p>如果你想知道这些故事板的性能表现，那么你应该知道，一次加载整个故事板是不是一个大问题。故事板并不是马上实例化所有的视图控制器，只有初始视图控制器的时候才会。因为你的初始视图控制器是一个标签栏控制器，它包含两个视图控制器也被加载。<br>然而别的控制器也并不实例化，直到你连线桥接给他们。当您关闭这些视图控制器，他们会立即释放，所以只有积极使用视图控制器是在内存中，就像如果你使用独立的nib一样。<br>让我们实践来看看。在<code>PlayerDetailsViewController.m</code>中添加下面的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (id)initWithCoder:(NSCoder *)aDecoder</div><div class="line">&#123;</div><div class="line">    if ((self = [super initWithCoder:aDecoder])) &#123;</div><div class="line">        NSLog(@&quot;init PlayerDetailsViewController&quot;);</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">- (void)dealloc</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;dealloc PlayerDetailsViewController&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你重写的<code>initWithCoder:</code>和<code>dealloc</code>的方法，使他们能在<strong>Xcode</strong>的调试窗口打印信息。现在再次运行该应用程序，并打开添加选手画(Add Player页面)。你应该能看到，这个时候视图控制器没有分配到内存。<br>当你关闭添加播放器屏幕(Add Player页面)，按点击取消或完成，你应该看到<code>dealloc</code>内的消息被打印。如果你再次打开这个页面，你也应该看到的<code>initWithCoder:</code>方法的响应。这应该向你保证，视图控制器是按需加载而已，就像他们如果你是手工加载nib一样。<br>关于静态单元格：他们只工作在<strong>UITableViewController</strong>。虽然界面生成器可以让你把它们作为一个<strong>Table View</strong>对象添加到一个普通的<strong>UIViewController</strong>中，但这将不会在运行时正常工作。这样做的原因是，<strong>UITableViewController</strong>中提供了一些额外的特殊照顾的数据源的静态单元格。 <strong>Xcode</strong>中甚至会阻止您编译这样一个项目，并显示错误消息：”非法配置：在嵌入的UITableViewController情况下的静态表视图才有效”。<br>原型单元格，另一方面，只是正常工作中，你放置一个表视图到普通视图控制器内。虽然是在nib下工作。目前，如果你想使用原型单元格或静态单元格，你必须使用一个故事板。</p>
<p>它不是不可想象的，你可能想，结合静态单元格和常规动态单元格的单表视图，但这不是很好被SKD支持。如果你需要在你的app中加入这些，你可以看看这个论坛:<a href="https://devforums.apple.com/message/505098" target="_blank" rel="external">his post on the Apple Developer Forums</a></p>

  </section>

</article>
<section class="read-more">
           
    
               
            <div class="read-more-item">
                <span class="read-more-item-dim">最近的文章</span>
                <h2 class="post-list__post-title post-title"><a href="/2015/01/04/2015-01-4-Dynamic-TableViewCell-Height-By-Auto Layout/" title="使用AutoLayout来动态计算UITableViewCell的高度">使用AutoLayout来动态计算UITableViewCell的高度</a></h2>
                <p class="excerpt">
                
                
Learn how to create dynamic height table view cells using auto layout引文原版：http://www.raywenderlich.com/73602/dynamic-table-view-cell-height-auto-layout转载请注明出处：http://www.rockerhx.com/2015/01/04/2015-01-4-Dynamic-TableViewCell-Height-By-Auto%20Layout/
11/23/2014: 已经更新兼容iOS7，iOS8和Xcode6.1

如果你在过去想创建一个自定义的表视图来完成动态适配表视图单元格的高度，你必须写很多的计算代码。你必须计算每一个label，image view，text field，以及其他一切单元格内手动创建的控件高度。坦率地说，这是非常艰巨的，也是流水账，而且还容易出错。在这个表视图单元格动态高度教程中，您将学习如何创建自定义单元格，并动态调整它们的大小，以适应它们的内容。如果你之前已经做过自定义单元格的工作，你可能在想，“这将需要大量的适配计算代码。”但是，如果我们告诉你，你一点也不用写任何适配计算代码呢？你可能会说“谬论！”。但是，你的确可以做到！通过你在本教程结束的时候，你就会知道如何利用自动布局来搞定你的几百行代码。

注：本教程适用于iOS7及以上。没有使用只有iOS8才支持的自动计算tableview cell的api。
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2015-01-04T12:42:30.000Z" class="post-list__meta--date date">1月 4 2015</time> &#8226; <span class="post-list__meta--tags tags">于&nbsp;
  <a class="tag-link" href="/tags/AutoLayout/">AutoLayout</a>, <a class="tag-link" href="/tags/iOS7/">iOS7</a>, <a class="tag-link" href="/tags/iOS8/">iOS8</a>
</span><a class="btn-border-small" href="/2015/01/04/2015-01-4-Dynamic-TableViewCell-Height-By-Auto Layout/">继续阅读</a></div>
                           
            </div>
        
        
               
            <div class="read-more-item">
                <span class="read-more-item-dim">更早的文章</span>
                <h2 class="post-list__post-title post-title"><a href="/2014/02/25/2014-02-25-IOS-MVC/" title="浅谈iOS中的MVC设计模式">浅谈iOS中的MVC设计模式</a></h2>
                <p class="excerpt">
                
                我们今天谈谈cocoa程序设计中的 模型－视图－控制器（MVC）范型。我们将从两大方面来讨论MVC：
什么是MVC？M、V、C之间的交流方式是什么样子的？ 

理解了MVC的概念，对cocoa程序开发是至关重要的。
##一、MVC的概念
MVC是Model-VIew-Controller，就是模型－视图－控制器，这些都是什么东西呢？MVC把软件系统分为三个部分：Model，View，Controller。在cocoa中，你的程序中的每一个object（对象）都将明显地仅属于这三部分中的一个，而完全不属于另外两个。

Model = 你的程序是什么(而不是你的程序是如何显示的)

                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2014-02-25T09:28:18.000Z" class="post-list__meta--date date">2月 25 2014</time> &#8226; <span class="post-list__meta--tags tags">于&nbsp;
  <a class="tag-link" href="/tags/MVC/">MVC</a>
</span><a class="btn-border-small" href="/2014/02/25/2014-02-25-IOS-MVC/">继续阅读</a></div>
                       
            </div>
        
     
   
   
  
</section>

            
            <footer class="footer">
    <span class="footer__copyright">
        本站点采用 <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>
    </span>
    <span class="footer__copyright">
        基于 <a href="http://hexo.io">Hexo</a> 搭建，感谢 <a href="https://pages.github.com/">GitHub Pages</a> 提供免费的托管服务
    </span>
    <span class="footer__copyright">
        &copy; 2016 - 本站由 <a href="/">@Monniya</a> 创建,
        使用 <a href="https://github.com/monniya/hexo-theme-new-vno ">hexo-theme-new-vno</a> 主题,
        修改自 <a href="https://github.com/lenbo-ma/hexo-theme-vno" target="_blank">Vno</a>, 原创出自<a href="http://github.com/onevcat/vno" target="_blank">onevcat</a>
    </span>
</footer>
        </div>
    </div>

    

     
    
    <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?f1811f144f64379f918cf1ef7bf3f3cb";
            var s = document.getElementsByTagName("script")[0]; 
            s.parentNode.insertBefore(hm, s);
        })();
    </script>



    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
    
    </script>
    
</body>
</html>
